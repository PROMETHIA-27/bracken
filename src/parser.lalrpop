use crate::ast::{File, FnDef, Expr, Stmt, Stmts};
use std::str::FromStr;

grammar;

pub File: File =
    <defs:FnDef*> => 
    File {
        def_ids: defs
            .iter()
            .enumerate()
            .map(|(i, def)| (def.name.clone(), i))
            .collect(),
        defs,
    };

pub FnDef: FnDef = 
    "function" <name:Ident> "()" <body:Stmts> "end" => FnDef { name, body };

pub Stmts: Stmts = <Stmt*> => Stmts(<>);

pub Stmt: Stmt = {
    <Expr> => Stmt::Expr(<>),
}

pub Expr = AssignExpr;

pub AssignExpr: Expr = {
    "let" <name:Ident> <ty:(":" <Ident>)?> "=" <value:AssignExpr> => Expr::Let { name, ty, value: Box::new(value) },
    <name:Ident> "=" <value:AssignExpr> => Expr::Set { name, value: Box::new(value) },
    ValueExpr,
}

pub ValueExpr: Expr = {
    <l:ValueExpr> "+" <r:Term> => Expr::Plus(Box::new(l), Box::new(r)),
    <l:ValueExpr> "-" <r:Term> => Expr::Minus(Box::new(l), Box::new(r)),
    Term,
}

pub Term: Expr = {
    <l:Term> "*" <r:Factor> => Expr::Times(Box::new(l), Box::new(r)),
    Factor,
}

pub Factor: Expr = {
    Return,
    While,
    Break,
    <Literal> => Expr::Literal(<>),
    <Ident> => Expr::Local(<>),
    "(" <Expr> ")" => <>,
}

pub Return: Expr =
    "return" "(" <value:Expr?> ")" => Expr::Return(value.map(Box::new));

pub While: Expr = 
    "while" <pred:Expr> <body:Stmts> "end" => Expr::While { pred: Box::new(pred), body };

pub Break: Expr = {
    "break" => Expr::Break(None),
}

pub Literal: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();

pub Ident: String = {
    <r"[a-zA-Z][_a-zA-Z0-9]*"> => <>.to_string(),
    <r"[0-9]+[a-zA-Z][_a-zA-Z0-9]*"> => <>.to_string(),
}