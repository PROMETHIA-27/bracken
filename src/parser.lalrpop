use std::str::FromStr;
use std::sync::Arc;

use crate::arena::{CellArena, CellExtendArena, CellInterner, Id};
use crate::ast::{File, FnDef, Expr, Stmt, Stmts};

grammar(
    source: &Arc<String>,
    exprs: &CellArena<Expr>, 
    exprlists: &CellArena<Vec<Id<Expr>>>,
    strings: &CellInterner<String>, 
    stmts: &CellArena<Stmts>, 
    spans: &CellExtendArena<Expr, (usize, usize)>
);

pub File: File = <defs:FnDef*> => File::new(
    source.clone(),
    exprs.take(), 
    exprlists.take(),
    spans.take(),
    strings.take(), 
    stmts.take(), 
    defs
);

pub FnDef: FnDef = 
    "function" <name:Ident> "(" <params:Comma<(<Ident> ":" <Ident>)>> ")" <ret_ty:("->" <Ident>)?> 
        <body:Stmts> 
    "end" 
    => FnDef::new(name, body, params, ret_ty);

pub Stmts: Id<Stmts> = <Stmt*> => stmts.push(Stmts::new(<>));

pub Stmt: Stmt = {
    <Expr> => Stmt::Expr(<>),
}

pub Expr: Id<Expr> = Spanned<AssignExpr>;

pub AssignExpr: Id<Expr> = {
    "let" <name:Ident> <ty:(":" <Ident>)?> "=" <value:Spanned<AssignExpr>> => 
        exprs.push(Expr::Let { name, ty, value }),
    <name:Ident> "=" <value:Spanned<AssignExpr>> => exprs.push(Expr::Set { name, value }),
    Spanned<ValueExpr>,
}

pub ValueExpr: Id<Expr> = {
    <l:Spanned<ValueExpr>> "+" <r:Spanned<Term>> => exprs.push(Expr::Plus(l, r)),
    <l:Spanned<ValueExpr>> "-" <r:Spanned<Term>> => exprs.push(Expr::Minus(l, r)),
    Term,
}

pub Term: Id<Expr> = {
    <l:Spanned<Term>> "*" <r:Spanned<Factor>> => exprs.push(Expr::Times(l, r)),
    Factor,
}

pub Factor: Id<Expr> = {
    Spanned<Return>,
    Spanned<While>,
    Spanned<Break>,
    <callee:Factor> "(" <params:Comma<Expr>> ")" => exprs.push(Expr::Call { 
        callee, 
        params: exprlists.push(params)
    }),
    <Literal> => exprs.push(Expr::Literal(<>)),
    <Ident> => exprs.push(Expr::Local(<>)),
    "{" <Expr> "}" => <>,
}

pub Return: Id<Expr> =
    "return" "(" <value:Expr?> ")" => exprs.push(Expr::Return(value));

pub While: Id<Expr> = 
    "while" <pred:Expr> <body:Stmts> "end" => exprs.push(Expr::While { pred, body });

pub Break: Id<Expr> = {
    "break" => exprs.push(Expr::Break(None)),
}

pub Literal: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();

pub Ident: Id<String> = {
    <r"[a-zA-Z][_a-zA-Z0-9]*"> => strings.add(<>.to_string()),
    <r"[0-9]+[a-zA-Z][_a-zA-Z0-9]*"> => strings.add(<>.to_string()),
}

Spanned<T>: T = {
    <l:@L> <t:T> <r:@R> => {
        spans.set(t, (l, r));
        t
    }
}

Comma<T>: Vec<T> = {
    <mut list:(<T> ",")*> <last:T?> => {
        if let Some(value) = last {
            list.push(value);
        }
        list
    }
}