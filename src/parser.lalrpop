use std::str::FromStr;

use crate::arena::{CellArena, CellInterner, Id};
use crate::ast::{File, FnDef, Expr, Stmt, Stmts};

grammar(exprs: &CellArena<Expr>, strings: &CellInterner<String>, stmts: &CellArena<Stmts>);

pub File: File = <defs:FnDef*> => File::new(
    exprs.take(), 
    strings.take(), 
    stmts.take(), 
    defs
);

pub FnDef: FnDef = 
    "function" <name:Ident> "()" <body:Stmts> "end" => FnDef::new(name, body);

pub Stmts: Id<Stmts> = <Stmt*> => stmts.push(Stmts::new(<>));

pub Stmt: Stmt = {
    <Expr> => Stmt::Expr(<>),
}

pub Expr: Id<Expr> = AssignExpr;

pub AssignExpr: Id<Expr> = {
    "let" <name:Ident> <ty:(":" <Ident>)?> "=" <value:AssignExpr> => 
        exprs.push(Expr::Let { name, ty, value }),
    <name:Ident> "=" <value:AssignExpr> => exprs.push(Expr::Set { name, value }),
    ValueExpr,
}

pub ValueExpr: Id<Expr> = {
    <l:ValueExpr> "+" <r:Term> => exprs.push(Expr::Plus(l, r)),
    <l:ValueExpr> "-" <r:Term> => exprs.push(Expr::Minus(l, r)),
    Term,
}

pub Term: Id<Expr> = {
    <l:Term> "*" <r:Factor> => exprs.push(Expr::Times(l, r)),
    Factor,
}

pub Factor: Id<Expr> = {
    Return,
    While,
    Break,
    <Literal> => exprs.push(Expr::Literal(<>)),
    <Ident> => exprs.push(Expr::Local(<>)),
    "(" <Expr> ")" => <>,
}

pub Return: Id<Expr> =
    "return" "(" <value:Expr?> ")" => exprs.push(Expr::Return(value));

pub While: Id<Expr> = 
    "while" <pred:Expr> <body:Stmts> "end" => exprs.push(Expr::While { pred, body });

pub Break: Id<Expr> = {
    "break" => exprs.push(Expr::Break(None)),
}

pub Literal: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();

pub Ident: Id<String> = {
    <r"[a-zA-Z][_a-zA-Z0-9]*"> => strings.add(<>.to_string()),
    <r"[0-9]+[a-zA-Z][_a-zA-Z0-9]*"> => strings.add(<>.to_string()),
}