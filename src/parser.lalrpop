use crate::ast::{File, FnDef, Expr, Stmt, Stmts};
use std::str::FromStr;
use std::collections::HashMap;

grammar;

pub File: File = {
    <def:FnDef> <mut file:File> => { 
        let name = def.name.clone();
        file.defs.push(def); 
        file.def_ids.insert(name, file.defs.len() - 1);
        file 
    },
    => File { defs: vec![], def_ids: HashMap::new() },
}

pub FnDef: FnDef = 
    "function" <name:Ident> "()" <body:Stmts> "end" => FnDef { name, body };

pub Stmts: Stmts = {
    <mut stmts:Stmts> <stmt:Stmt> => {
        stmts.0.push(stmt);
        stmts
    },
    => Stmts(vec![]),
}

pub Stmt: Stmt = {
    <Expr> => Stmt::Expr(<>),
}

pub Expr = AssignExpr;

pub AssignExpr: Expr = {
    "let" <name:Ident> "=" <value:AssignExpr> => Expr::Let { name, value: Box::new(value) },
    <name:Ident> "=" <value:AssignExpr> => Expr::Set { name, value: Box::new(value) },
    ValueExpr,
}

pub ValueExpr: Expr = {
    <l:ValueExpr> "+" <r:Term> => Expr::Plus(Box::new(l), Box::new(r)),
    <l:ValueExpr> "-" <r:Term> => Expr::Minus(Box::new(l), Box::new(r)),
    Term,
}

pub Term: Expr = {
    <l:Term> "*" <r:Factor> => Expr::Times(Box::new(l), Box::new(r)),
    Factor,
}

pub Factor: Expr = {
    Return,
    While,
    Break,
    <Literal> => Expr::Literal(<>),
    <Ident> => Expr::Local(<>),
    "(" <Expr> ")" => <>,
}

pub Return: Expr = {
    "return" "(" <value:Expr> ")" => Expr::Return(Some(Box::new(value))),
    "return" "(" ")" => Expr::Return(None),
}

pub While: Expr = 
    "while" <pred:Expr> <body:Stmts> "end" => Expr::While { pred: Box::new(pred), body };

pub Break: Expr = {
    "break" => Expr::Break(None),
}

pub Literal: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();

pub Ident: String = {
    <r"[a-zA-Z][_a-zA-Z0-9]*"> => <>.to_string(),
    <r"[0-9]+[a-zA-Z][_a-zA-Z0-9]*"> => <>.to_string(),
}